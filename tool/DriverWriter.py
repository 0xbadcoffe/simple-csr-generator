#!/usr/bin/python
#########################################################################################
# Copyright 2020 by Heqing Huang (heqinghuangusc@gmail.com)
#
# Project: Simple CSR Generator
# Author: Heqing Huang
# Created: 10/28/2020
#
# Description:
#   This script takes the result from YmlParser and write a HTML documentation
#
#########################################################################################

from common import *

# Define the index for each register
REGNAME = 0
ADDR    = 1
FLDLIST = 2

# Define the index for each field Array
# [Name, MSb, LSb, SWTYPE, HWTYPE, Reset Value, Description]
FNAME   = 0
MSB     = 1
LSB     = 2
SWTYPE  = 3
HWTYPE  = 4
RESET   = 5
NOTE    = 6

SPACE = 60

OFT_SUFFIX = '__OFT'
MSK_SUFFIX = '__MASK'
SET_SUFFIX = '__set'
GET_SUFFIX = '__get'

space1 = '        '
mask = lambda offset, size: hex(int(bin(2 ** size - 1), 2) << offset)
lines = lambda x: '\n' * x

class DriverWriter(object):

    def __init__(self, regsInfo, name, path):
        """
        Parameters:
            :param regsInfo: the register info array for all register
            :param name: the name of the register module
            :param path: the path of to the document
        """
        self.regsInfo = regsInfo
        self.name = name
        self.NAME = name.upper()
        self.path = path

    def prefix(self, FILE, name):
        """
        Write the header par of the HTML file
        Parameters:
            :param name: the name of the register module
            :param FILE: The file pointer
        """
        string = ''
        string += f'//////////////////////////////////////////////////////\n'
        string += f'//\n'
        string += f'// Driver for {name} CSR module\n'
        string += f'// Generated by Simple CSR Generator\n'
        string += f'// Created: {MONTH}/{DAY}/{YEAR} {HOUR}:{MINUTE}\n'
        string += f'//\n'
        string += f'//////////////////////////////////////////////////////\n'
        string += lines(2)
        FILE.write(string)

    def getFieldStr(self, reg, name):
        """
            write the macro to get this field from register data
        """
        oft  = f'{reg}__{name}{OFT_SUFFIX}'
        mask = f'{reg}__{name}{MSK_SUFFIX}'
        string  = f'#define {reg}__{name}{GET_SUFFIX}(data) \\\n'
        string += f'{space1}((data >> {oft}) & {mask})\n'
        return string

    def setFieldStr(self, reg, name):
        """
            write the macro to set this field for register data
            return the string of the define statement and the macro name
        """
        oft  = f'{reg}__{name}{OFT_SUFFIX}'
        mask = f'{reg}__{name}{MSK_SUFFIX}'
        macro = f'{reg}__{name}{SET_SUFFIX}({name})'
        string  = f'#define {macro} \\\n'
        string += f'{space1}(({name} << {oft}) & {mask})\n'
        return string

    def OneFieldStr(self, fieldInfo, reg):
        """
            Write driver for one field.
            Returns a string of the content to be written

            Parameters:
                :param regInfo: the register info array for 1 register
        """
        name = fieldInfo[FNAME].upper()
        msb = fieldInfo[MSB]
        lsb = fieldInfo[LSB]
        size = msb - lsb + 1
        offset = lsb
        if name == RSVR:
            return ''
        string  = f'// Field: {name}, Offset: {offset}, Size: {size}\n'
        string += addSpace(f'#define {reg}__{name}{OFT_SUFFIX}', SPACE) + f'{offset}\n'
        string += addSpace(f'#define {reg}__{name}{MSK_SUFFIX}', SPACE) + f'{mask(offset,size)}\n'
        string += self.getFieldStr(reg, name)
        string += self.setFieldStr(reg, name)
        string += lines(1)
        return string

    def setRegStr(self, reg, nameList):
        """
            Write the macro to set register value
        """
        nameString = ''
        string1 = ''
        for name in reversed(nameList):
            if name != RSVR:
                nameString += f'{name}, '
                macro = f'{reg}__{name}{SET_SUFFIX}({name})'
                string1 += space1 + f'{macro} | \\\n'

        nameString = nameString[:-2]    # get rid of last ', '
        string0  = f'#define {reg}__set({nameString}) (\\\n'
        string1 = string1[:-5]
        string1 += ')\n'
        return string0 + string1

    def writeOneReg(self, FILE, regInfo):
        """
            Write driver for one register.
        """
        reg = self.NAME + '__' + regInfo[REGNAME].upper()
        addr = hex(regInfo[ADDR])
        nameList = []
        string  = f'// =============================================\n'
        string += f'// Register: {regInfo[REGNAME]}, Address: {addr}\n'
        string += f'// =============================================\n'
        string += f'#define {reg}\n'
        string += addSpace(f'#define {reg}_ADDR', SPACE) + f'{addr}\n\n'
        for fieldInfo in regInfo[FLDLIST]:
            nameList.append(fieldInfo[FNAME].upper())
            string += self.OneFieldStr(fieldInfo, reg)
        string += self.setRegStr(reg, nameList)
        string += lines(2)
        FILE.write(string)


    def writeAllReg(self, FILE, regsInfo):
        """
            Write all the register.
            Parameters:
                :param FILE: The file pointer
                :param regsInfo: the register info array for all the register
        """
        for regInfo in regsInfo:
            self.writeOneReg(FILE, regInfo)

    def writeDriver(self):
        """
            Write all the content.
        """
        fullpath = self.path + '/' + self.name + '_csr.h'
        FILE = open(fullpath, "w")
        self.prefix(FILE, self.name)
        self.writeAllReg(FILE, self.regsInfo)
        FILE.close()

